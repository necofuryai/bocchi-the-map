// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

// User query parameter structs

type GetUserByProviderIDParams struct {
	AuthProvider   UsersAuthProvider `json:"auth_provider"`
	AuthProviderID string            `json:"auth_provider_id"`
}

type CreateUserParams struct {
	ID             string            `json:"id"`
	Email          string            `json:"email"`
	DisplayName    string            `json:"display_name"`
	AvatarUrl      sql.NullString    `json:"avatar_url"`
	AuthProvider   UsersAuthProvider `json:"auth_provider"`
	AuthProviderID string            `json:"auth_provider_id"`
	Preferences    json.RawMessage   `json:"preferences"`
}

type UpsertUserParams struct {
	ID             string            `json:"id"`
	Email          string            `json:"email"`
	DisplayName    string            `json:"display_name"`
	AvatarUrl      sql.NullString    `json:"avatar_url"`
	AuthProvider   UsersAuthProvider `json:"auth_provider"`
	AuthProviderID string            `json:"auth_provider_id"`
	Preferences    json.RawMessage   `json:"preferences"`
}

type UpdateUserAvatarParams struct {
	AvatarUrl sql.NullString `json:"avatar_url"`
	ID        string         `json:"id"`
}

type UpdateUserPreferencesParams struct {
	Preferences json.RawMessage `json:"preferences"`
	ID          string          `json:"id"`
}

// Token blacklist parameter structs

type AddToBlacklistParams struct {
	Jti       string                  `json:"jti"`
	UserID    string                  `json:"user_id"`
	TokenType TokenBlacklistTokenType `json:"token_type"`
	ExpiresAt time.Time               `json:"expires_at"`
	Reason    sql.NullString          `json:"reason"`
}

type BlacklistAccessTokenParams struct {
	Jti       string    `json:"jti"`
	UserID    string    `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

type BlacklistRefreshTokenParams struct {
	Jti       string    `json:"jti"`
	UserID    string    `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

// Query implementations

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, "SELECT * FROM users WHERE id = ? LIMIT 1", id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.AuthProvider,
		&i.AuthProviderID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, "SELECT * FROM users WHERE email = ? LIMIT 1", email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.AuthProvider,
		&i.AuthProviderID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

func (q *Queries) GetUserByProviderID(ctx context.Context, arg GetUserByProviderIDParams) (User, error) {
	row := q.db.QueryRowContext(ctx, "SELECT * FROM users WHERE auth_provider = ? AND auth_provider_id = ? LIMIT 1", arg.AuthProvider, arg.AuthProviderID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.AuthProvider,
		&i.AuthProviderID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, `
		INSERT INTO users (
			id, email, display_name, avatar_url, auth_provider, auth_provider_id, 
			preferences, created_at, updated_at
		) VALUES (
			?, ?, ?, ?, ?, ?, ?, NOW(), NOW()
		)`, 
		arg.ID,
		arg.Email,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.AuthProvider,
		arg.AuthProviderID,
		arg.Preferences,
	)
	return err
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.ExecContext(ctx, `
		INSERT INTO users (
			id, email, display_name, avatar_url, auth_provider, auth_provider_id, 
			preferences, created_at, updated_at
		) VALUES (
			?, ?, ?, ?, ?, ?, ?, NOW(), NOW()
		)
		ON DUPLICATE KEY UPDATE
			email = VALUES(email),
			display_name = VALUES(display_name),
			avatar_url = VALUES(avatar_url),
			preferences = VALUES(preferences),
			updated_at = NOW()`,
		arg.ID,
		arg.Email,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.AuthProvider,
		arg.AuthProviderID,
		arg.Preferences,
	)
	return err
}

func (q *Queries) UpdateUserAvatar(ctx context.Context, arg UpdateUserAvatarParams) error {
	_, err := q.db.ExecContext(ctx, "UPDATE users SET avatar_url = ?, updated_at = NOW() WHERE id = ?", arg.AvatarUrl, arg.ID)
	return err
}

func (q *Queries) UpdateUserPreferences(ctx context.Context, arg UpdateUserPreferencesParams) error {
	_, err := q.db.ExecContext(ctx, "UPDATE users SET preferences = ?, updated_at = NOW() WHERE id = ?", arg.Preferences, arg.ID)
	return err
}

// Token blacklist query implementations

func (q *Queries) AddToBlacklist(ctx context.Context, arg AddToBlacklistParams) error {
	_, err := q.db.ExecContext(ctx, `
		INSERT INTO token_blacklist (jti, user_id, token_type, expires_at, revoked_at, reason) 
		VALUES (?, ?, ?, ?, NOW(), ?)`,
		arg.Jti,
		arg.UserID,
		arg.TokenType,
		arg.ExpiresAt,
		arg.Reason,
	)
	return err
}

func (q *Queries) BlacklistAccessToken(ctx context.Context, arg BlacklistAccessTokenParams) error {
	_, err := q.db.ExecContext(ctx, `
		INSERT INTO token_blacklist (jti, user_id, token_type, expires_at, revoked_at, reason) 
		VALUES (?, ?, 'access', ?, NOW(), 'logout')`,
		arg.Jti,
		arg.UserID,
		arg.ExpiresAt,
	)
	return err
}

func (q *Queries) BlacklistRefreshToken(ctx context.Context, arg BlacklistRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, `
		INSERT INTO token_blacklist (jti, user_id, token_type, expires_at, revoked_at, reason) 
		VALUES (?, ?, 'refresh', ?, NOW(), 'logout')`,
		arg.Jti,
		arg.UserID,
		arg.ExpiresAt,
	)
	return err
}

func (q *Queries) IsTokenBlacklisted(ctx context.Context, jti string) (bool, error) {
	row := q.db.QueryRowContext(ctx, `
		SELECT EXISTS(
			SELECT 1 FROM token_blacklist 
			WHERE jti = ? AND expires_at > NOW()
		) as is_blacklisted`, jti)
	var isBlacklisted bool
	err := row.Scan(&isBlacklisted)
	return isBlacklisted, err
}

func (q *Queries) CleanupExpiredTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, "DELETE FROM token_blacklist WHERE expires_at <= NOW()")
	return err
}