// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: spots.sql

package database

import (
	"context"
	"encoding/json"
)

const createSpot = `-- name: CreateSpot :exec
INSERT INTO spots (
    id, name, name_i18n, latitude, longitude, category, address, address_i18n, country_code
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateSpotParams struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	NameI18n    json.RawMessage `json:"name_i18n"`
	Latitude    string          `json:"latitude"`
	Longitude   string          `json:"longitude"`
	Category    string          `json:"category"`
	Address     string          `json:"address"`
	AddressI18n json.RawMessage `json:"address_i18n"`
	CountryCode string          `json:"country_code"`
}

func (q *Queries) CreateSpot(ctx context.Context, arg CreateSpotParams) error {
	_, err := q.db.ExecContext(ctx, createSpot,
		arg.ID,
		arg.Name,
		arg.NameI18n,
		arg.Latitude,
		arg.Longitude,
		arg.Category,
		arg.Address,
		arg.AddressI18n,
		arg.CountryCode,
	)
	return err
}

const deleteSpot = `-- name: DeleteSpot :exec
DELETE FROM spots 
WHERE id = ?
`

func (q *Queries) DeleteSpot(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSpot, id)
	return err
}

const getSpotByID = `-- name: GetSpotByID :one
SELECT id, name, name_i18n, latitude, longitude, category, address, address_i18n, country_code, average_rating, review_count, created_at, updated_at FROM spots 
WHERE id = ?
`

func (q *Queries) GetSpotByID(ctx context.Context, id string) (Spot, error) {
	row := q.db.QueryRowContext(ctx, getSpotByID, id)
	var i Spot
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NameI18n,
		&i.Latitude,
		&i.Longitude,
		&i.Category,
		&i.Address,
		&i.AddressI18n,
		&i.CountryCode,
		&i.AverageRating,
		&i.ReviewCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSpotsByLocation = `-- name: ListSpotsByLocation :many
SELECT id, name, name_i18n, latitude, longitude, category, address, address_i18n, country_code, average_rating, review_count, created_at, updated_at FROM spots 
WHERE (6371 * acos(
    cos(radians(?)) * cos(radians(latitude)) * 
    cos(radians(longitude) - radians(?)) + 
    sin(radians(?)) * sin(radians(latitude))
)) <= ?
ORDER BY (6371 * acos(
    cos(radians(?)) * cos(radians(latitude)) * 
    cos(radians(longitude) - radians(?)) + 
    sin(radians(?)) * sin(radians(latitude))
))
LIMIT ? OFFSET ?
`

type ListSpotsByLocationParams struct {
	Latitude   string `json:"latitude"`
	Longitude  string `json:"longitude"`
	Latitude_2 string `json:"latitude_2"`
	RadiusKm   string `json:"radius_km"`
	Latitude_3 string `json:"latitude_3"`
	Longitude_2 string `json:"longitude_2"`
	Latitude_4 string `json:"latitude_4"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListSpotsByLocation(ctx context.Context, arg ListSpotsByLocationParams) ([]Spot, error) {
	rows, err := q.db.QueryContext(ctx, listSpotsByLocation,
		arg.Latitude,
		arg.Longitude,
		arg.Latitude_2,
		arg.RadiusKm,
		arg.Latitude_3,
		arg.Longitude_2,
		arg.Latitude_4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spot{}
	for rows.Next() {
		var i Spot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NameI18n,
			&i.Latitude,
			&i.Longitude,
			&i.Category,
			&i.Address,
			&i.AddressI18n,
			&i.CountryCode,
			&i.AverageRating,
			&i.ReviewCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countSpotsByLocation = `-- name: CountSpotsByLocation :one
SELECT COUNT(*) FROM spots 
WHERE (6371 * acos(
    cos(radians(?)) * cos(radians(latitude)) * 
    cos(radians(longitude) - radians(?)) + 
    sin(radians(?)) * sin(radians(latitude))
)) <= ?
`

type CountSpotsByLocationParams struct {
	Latitude   string `json:"latitude"`
	Longitude  string `json:"longitude"`
	Latitude_2 string `json:"latitude_2"`
	RadiusKm   string `json:"radius_km"`
}

func (q *Queries) CountSpotsByLocation(ctx context.Context, arg CountSpotsByLocationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSpotsByLocation,
		arg.Latitude,
		arg.Longitude,
		arg.Latitude_2,
		arg.RadiusKm,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchSpots = `-- name: SearchSpots :many
SELECT id, name, name_i18n, latitude, longitude, category, address, address_i18n, country_code, average_rating, review_count, created_at, updated_at FROM spots 
WHERE (name LIKE ? OR address LIKE ?)
  AND (? = '' OR category = ?)
  AND (? = '' OR country_code = ?)
  AND (? = 0 OR (6371 * acos(
      cos(radians(?)) * cos(radians(latitude)) * 
      cos(radians(longitude) - radians(?)) + 
      sin(radians(?)) * sin(radians(latitude))
  )) <= ?)
ORDER BY 
  CASE WHEN name LIKE ? THEN 1 ELSE 2 END,
  average_rating DESC,
  review_count DESC
LIMIT ? OFFSET ?
`

type SearchSpotsParams struct {
	Name        string `json:"name"`
	Address     string `json:"address"`
	Category    string `json:"category"`
	Category_2  string `json:"category_2"`
	CountryCode string `json:"country_code"`
	CountryCode_2 string `json:"country_code_2"`
	RadiusKm    string `json:"radius_km"`
	Latitude    string `json:"latitude"`
	Longitude   string `json:"longitude"`
	Latitude_2  string `json:"latitude_2"`
	RadiusKm_2  string `json:"radius_km_2"`
	Name_2      string `json:"name_2"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) SearchSpots(ctx context.Context, arg SearchSpotsParams) ([]Spot, error) {
	rows, err := q.db.QueryContext(ctx, searchSpots,
		arg.Name,
		arg.Address,
		arg.Category,
		arg.Category_2,
		arg.CountryCode,
		arg.CountryCode_2,
		arg.RadiusKm,
		arg.Latitude,
		arg.Longitude,
		arg.Latitude_2,
		arg.RadiusKm_2,
		arg.Name_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spot{}
	for rows.Next() {
		var i Spot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NameI18n,
			&i.Latitude,
			&i.Longitude,
			&i.Category,
			&i.Address,
			&i.AddressI18n,
			&i.CountryCode,
			&i.AverageRating,
			&i.ReviewCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpot = `-- name: UpdateSpot :exec
UPDATE spots 
SET name = ?, name_i18n = ?, latitude = ?, longitude = ?, category = ?, 
    address = ?, address_i18n = ?, country_code = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateSpotParams struct {
	Name        string          `json:"name"`
	NameI18n    json.RawMessage `json:"name_i18n"`
	Latitude    string          `json:"latitude"`
	Longitude   string          `json:"longitude"`
	Category    string          `json:"category"`
	Address     string          `json:"address"`
	AddressI18n json.RawMessage `json:"address_i18n"`
	CountryCode string          `json:"country_code"`
	ID          string          `json:"id"`
}

func (q *Queries) UpdateSpot(ctx context.Context, arg UpdateSpotParams) error {
	_, err := q.db.ExecContext(ctx, updateSpot,
		arg.Name,
		arg.NameI18n,
		arg.Latitude,
		arg.Longitude,
		arg.Category,
		arg.Address,
		arg.AddressI18n,
		arg.CountryCode,
		arg.ID,
	)
	return err
}

const updateSpotRating = `-- name: UpdateSpotRating :exec
UPDATE spots 
SET average_rating = ?, review_count = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateSpotRatingParams struct {
	AverageRating string `json:"average_rating"`
	ReviewCount   int32  `json:"review_count"`
	ID            string `json:"id"`
}

func (q *Queries) UpdateSpotRating(ctx context.Context, arg UpdateSpotRatingParams) error {
	_, err := q.db.ExecContext(ctx, updateSpotRating,
		arg.AverageRating,
		arg.ReviewCount,
		arg.ID,
	)
	return err
}