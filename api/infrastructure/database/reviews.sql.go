// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reviews.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const countReviewsBySpot = `-- name: CountReviewsBySpot :one
SELECT COUNT(*) FROM reviews 
WHERE spot_id = ?
`

func (q *Queries) CountReviewsBySpot(ctx context.Context, spotID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countReviewsBySpot, spotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReviewsByUser = `-- name: CountReviewsByUser :one
SELECT COUNT(*) FROM reviews 
WHERE user_id = ?
`

func (q *Queries) CountReviewsByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countReviewsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTopRatedSpots = `-- name: CountTopRatedSpots :one
SELECT COUNT(*) FROM (
  SELECT s.id FROM spots s
  LEFT JOIN reviews r ON s.id = r.spot_id
  GROUP BY s.id
  HAVING COUNT(r.id) >= ?
) AS filtered_spots
`

func (q *Queries) CountTopRatedSpots(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTopRatedSpots, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReview = `-- name: CreateReview :exec
INSERT INTO reviews (
    id, spot_id, user_id, rating, comment, rating_aspects
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateReviewParams struct {
	ID            string          `json:"id"`
	SpotID        string          `json:"spot_id"`
	UserID        string          `json:"user_id"`
	Rating        int32           `json:"rating"`
	Comment       sql.NullString  `json:"comment"`
	RatingAspects json.RawMessage `json:"rating_aspects"`
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) error {
	_, err := q.db.ExecContext(ctx, createReview,
		arg.ID,
		arg.SpotID,
		arg.UserID,
		arg.Rating,
		arg.Comment,
		arg.RatingAspects,
	)
	return err
}

const deleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews 
WHERE id = ?
`

func (q *Queries) DeleteReview(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReview, id)
	return err
}

const getReviewByID = `-- name: GetReviewByID :one
SELECT id, spot_id, user_id, rating, comment, rating_aspects, created_at, updated_at FROM reviews 
WHERE id = ?
`

func (q *Queries) GetReviewByID(ctx context.Context, id string) (Review, error) {
	row := q.db.QueryRowContext(ctx, getReviewByID, id)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.SpotID,
		&i.UserID,
		&i.Rating,
		&i.Comment,
		&i.RatingAspects,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewByUserAndSpot = `-- name: GetReviewByUserAndSpot :one
SELECT id, spot_id, user_id, rating, comment, rating_aspects, created_at, updated_at FROM reviews 
WHERE user_id = ? AND spot_id = ?
`

type GetReviewByUserAndSpotParams struct {
	UserID string `json:"user_id"`
	SpotID string `json:"spot_id"`
}

func (q *Queries) GetReviewByUserAndSpot(ctx context.Context, arg GetReviewByUserAndSpotParams) (Review, error) {
	row := q.db.QueryRowContext(ctx, getReviewByUserAndSpot, arg.UserID, arg.SpotID)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.SpotID,
		&i.UserID,
		&i.Rating,
		&i.Comment,
		&i.RatingAspects,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSpotRatingStats = `-- name: GetSpotRatingStats :one
SELECT 
    AVG(rating) as average_rating,
    COUNT(*) as review_count,
    SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as five_star_count,
    SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as four_star_count,
    SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as three_star_count,
    SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END) as two_star_count,
    SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END) as one_star_count
FROM reviews 
WHERE spot_id = ?
`

type GetSpotRatingStatsRow struct {
	AverageRating  interface{} `json:"average_rating"`
	ReviewCount    int64       `json:"review_count"`
	FiveStarCount  interface{} `json:"five_star_count"`
	FourStarCount  interface{} `json:"four_star_count"`
	ThreeStarCount interface{} `json:"three_star_count"`
	TwoStarCount   interface{} `json:"two_star_count"`
	OneStarCount   interface{} `json:"one_star_count"`
}

func (q *Queries) GetSpotRatingStats(ctx context.Context, spotID string) (GetSpotRatingStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSpotRatingStats, spotID)
	var i GetSpotRatingStatsRow
	err := row.Scan(
		&i.AverageRating,
		&i.ReviewCount,
		&i.FiveStarCount,
		&i.FourStarCount,
		&i.ThreeStarCount,
		&i.TwoStarCount,
		&i.OneStarCount,
	)
	return i, err
}

const listReviewsBySpot = `-- name: ListReviewsBySpot :many
SELECT
  r.id,
  r.spot_id,
  r.user_id,
  r.rating,
  r.comment,
  r.rating_aspects,
  r.created_at,
  r.updated_at,
  u.display_name  AS user_name,
  u.avatar_url    AS user_avatar
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.spot_id = ?
ORDER BY r.created_at DESC
LIMIT ? OFFSET ?
`

type ListReviewsBySpotParams struct {
	SpotID string `json:"spot_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListReviewsBySpotRow struct {
	ID            string          `json:"id"`
	SpotID        string          `json:"spot_id"`
	UserID        string          `json:"user_id"`
	Rating        int32           `json:"rating"`
	Comment       sql.NullString  `json:"comment"`
	RatingAspects json.RawMessage `json:"rating_aspects"`
	CreatedAt     time.Time       `json:"created_at"`
	UpdatedAt     time.Time       `json:"updated_at"`
	UserName      string          `json:"user_name"`
	UserAvatar    sql.NullString  `json:"user_avatar"`
}

func (q *Queries) ListReviewsBySpot(ctx context.Context, arg ListReviewsBySpotParams) ([]ListReviewsBySpotRow, error) {
	rows, err := q.db.QueryContext(ctx, listReviewsBySpot, arg.SpotID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReviewsBySpotRow{}
	for rows.Next() {
		var i ListReviewsBySpotRow
		if err := rows.Scan(
			&i.ID,
			&i.SpotID,
			&i.UserID,
			&i.Rating,
			&i.Comment,
			&i.RatingAspects,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.UserAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviewsByUser = `-- name: ListReviewsByUser :many
SELECT r.id, r.spot_id, r.user_id, r.rating, r.comment, r.rating_aspects, r.created_at, r.updated_at, s.name as spot_name, s.category as spot_category
FROM reviews r
JOIN spots s ON r.spot_id = s.id
WHERE r.user_id = ?
ORDER BY r.created_at DESC
LIMIT ? OFFSET ?
`

type ListReviewsByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListReviewsByUserRow struct {
	ID            string          `json:"id"`
	SpotID        string          `json:"spot_id"`
	UserID        string          `json:"user_id"`
	Rating        int32           `json:"rating"`
	Comment       sql.NullString  `json:"comment"`
	RatingAspects json.RawMessage `json:"rating_aspects"`
	CreatedAt     time.Time       `json:"created_at"`
	UpdatedAt     time.Time       `json:"updated_at"`
	SpotName      string          `json:"spot_name"`
	SpotCategory  string          `json:"spot_category"`
}

func (q *Queries) ListReviewsByUser(ctx context.Context, arg ListReviewsByUserParams) ([]ListReviewsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listReviewsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReviewsByUserRow{}
	for rows.Next() {
		var i ListReviewsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.SpotID,
			&i.UserID,
			&i.Rating,
			&i.Comment,
			&i.RatingAspects,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SpotName,
			&i.SpotCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopRatedSpots = `-- name: ListTopRatedSpots :many
SELECT
  s.id,
  s.name,
  s.category,
  s.address,
  s.latitude,
  s.longitude,
  s.country_code,
  s.average_rating,
  s.review_count,
  s.created_at,
  s.updated_at,
  AVG(r.rating)  AS avg_rating,
  COUNT(r.id)    AS total_reviews
FROM spots s
LEFT JOIN reviews r ON s.id = r.spot_id
GROUP BY s.id, s.name, s.category, s.address, s.latitude, s.longitude, s.country_code, s.average_rating, s.review_count, s.created_at, s.updated_at
HAVING COUNT(r.id) >= ?
ORDER BY avg_rating DESC, total_reviews DESC
LIMIT ? OFFSET ?
`

type ListTopRatedSpotsParams struct {
	ID     string `json:"id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListTopRatedSpotsRow struct {
	ID            string      `json:"id"`
	Name          string      `json:"name"`
	Category      string      `json:"category"`
	Address       string      `json:"address"`
	Latitude      string      `json:"latitude"`
	Longitude     string      `json:"longitude"`
	CountryCode   string      `json:"country_code"`
	AverageRating string      `json:"average_rating"`
	ReviewCount   int32       `json:"review_count"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	AvgRating     interface{} `json:"avg_rating"`
	TotalReviews  int64       `json:"total_reviews"`
}

func (q *Queries) ListTopRatedSpots(ctx context.Context, arg ListTopRatedSpotsParams) ([]ListTopRatedSpotsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTopRatedSpots, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTopRatedSpotsRow{}
	for rows.Next() {
		var i ListTopRatedSpotsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.CountryCode,
			&i.AverageRating,
			&i.ReviewCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvgRating,
			&i.TotalReviews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReview = `-- name: UpdateReview :exec
UPDATE reviews 
SET rating = ?, comment = ?, rating_aspects = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateReviewParams struct {
	Rating        int32           `json:"rating"`
	Comment       sql.NullString  `json:"comment"`
	RatingAspects json.RawMessage `json:"rating_aspects"`
	ID            string          `json:"id"`
}

func (q *Queries) UpdateReview(ctx context.Context, arg UpdateReviewParams) error {
	_, err := q.db.ExecContext(ctx, updateReview,
		arg.Rating,
		arg.Comment,
		arg.RatingAspects,
		arg.ID,
	)
	return err
}
